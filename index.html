<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>æ‰“ç£šå¡Š</title>
<style>
body {
    margin: 0;
    background: #222;
    color: #fff;
    text-align: center;
    font-family: Arial;
    touch-action: none;
}
canvas {
    background: #000;
    display: block;
    margin: 8px auto;
    border: 2px solid #fff;
}
button {
    padding: 12px 24px;
    margin: 6px;
    font-size: 16px;
}
</style>
</head>
<body>

<h2>æ‰“ç£šå¡Š</h2>

<div id="menu">
    <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
    <button onclick="restartGame()">å†ä¾†ä¸€å±€</button>
    <button onclick="showHighScores()">æŸ¥çœ‹é«˜åˆ†</button>
</div>

<div id="highScorePanel" style="display:none;">
    <h3>ğŸ† é«˜åˆ†æ¦œ</h3>
    <ol id="highScoreList"></ol>
    <button onclick="backToMenu()">è¿”å›é¸å–®</button>
</div>

<canvas id="game"></canvas>
<p id="info"></p>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ---------- è‡ªé©æ‡‰ ---------- */
function resizeCanvas() {
    const maxWidth = 500;
    const w = Math.min(window.innerWidth - 16, maxWidth);
    canvas.width = w;
    canvas.height = Math.floor(w * 1.4);
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

/* ---------- ç‹€æ…‹ ---------- */
let score, lives, gameOver, ballLaunched, animationId;
let level = 1;

/* ---------- å¹³å° ---------- */
const paddle = { width: 0, height: 12, x: 0, speed: 7 };

/* ---------- çƒï¼ˆå«ä¸Šä¸€å¹€ä½ç½®ï¼‰ ---------- */
const ball = {
    x: 0, y: 0,
    prevX: 0, prevY: 0,
    r: 8,
    dx: 0, dy: 0
};

/* ---------- ç‰©ç† ---------- */
const maxBounceAngle = 60;
const baseBallSpeed = 5;

/* ---------- ç£šå¡Š ---------- */
const brickRow = 6, brickCol = 10;
const brickPadding = 6, brickOffsetTop = 40;
let brickWidth, brickHeight = 18;
let bricks = [];

/* ---------- å·¥å…· ---------- */
function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

/* ---------- è¼¸å…¥ ---------- */
let leftPressed = false, rightPressed = false;
document.addEventListener("keydown", e => {
    if (e.key === "ArrowLeft") leftPressed = true;
    if (e.key === "ArrowRight") rightPressed = true;
    if (e.key === " " && !ballLaunched && !gameOver) launchBall();
});
document.addEventListener("keyup", e => {
    if (e.key === "ArrowLeft") leftPressed = false;
    if (e.key === "ArrowRight") rightPressed = false;
});
canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    paddle.x = clamp(x - paddle.width / 2, 0, canvas.width - paddle.width);
});
canvas.addEventListener("touchstart", () => {
    if (!ballLaunched && !gameOver) launchBall();
});

/* ---------- é¸å–® ---------- */
function startGame() {
    document.getElementById("menu").style.display = "none";
    document.getElementById("highScorePanel").style.display = "none";
    canvas.style.display = "block";
    level = 1;
    initGame();
}
function restartGame() {
    cancelAnimationFrame(animationId);
    startGame();
}
function backToMenu() {
    document.getElementById("highScorePanel").style.display = "none";
    document.getElementById("menu").style.display = "block";
}
function showHighScores() {
    const list = document.getElementById("highScoreList");
    list.innerHTML = "";
    getHighScores().forEach(s => {
        const li = document.createElement("li");
        li.textContent = s;
        list.appendChild(li);
    });
    document.getElementById("menu").style.display = "none";
    document.getElementById("highScorePanel").style.display = "block";
}

/* ---------- é«˜åˆ† ---------- */
function saveHighScore(s) {
    let scores = getHighScores();
    scores.push(s);
    scores.sort((a,b)=>b-a);
    localStorage.setItem("brickHighScores", JSON.stringify(scores.slice(0,5)));
}
function getHighScores() {
    return JSON.parse(localStorage.getItem("brickHighScores")) || [];
}

/* ---------- åˆå§‹åŒ– ---------- */
function initGame() {
    score = 0;
    lives = 3;
    gameOver = false;

    paddle.width = canvas.width * 0.22;
    paddle.x = canvas.width / 2 - paddle.width / 2;
    brickWidth = (canvas.width - (brickCol + 1) * brickPadding) / brickCol;

    createBricks();
    resetBall();
    draw();
}

/* ---------- ç£šå¡Š ---------- */
function createBricks() {
    bricks = [];
    const hp = level === 1 ? 1 : 2;
    for (let r = 0; r < brickRow; r++) {
        bricks[r] = [];
        for (let c = 0; c < brickCol; c++) {
            bricks[r][c] = { x: 0, y: 0, hp };
        }
    }
}

/* ---------- çƒ ---------- */
function getBallSpeed() {
    return baseBallSpeed + Math.floor(score / 5);
}
function launchBall() {
    const speed = getBallSpeed();
    ball.dx = 0;
    ball.dy = -speed;
    ballLaunched = true;
}
function resetBall() {
    ballLaunched = false;
    ball.x = paddle.x + paddle.width / 2;
    ball.y = canvas.height - paddle.height - 10 - ball.r;
    ball.dx = 0;
    ball.dy = 0;
}

/* ---------- ç£šå¡Šè²¼åˆç¢°æ’ ---------- */
function collisionDetection() {
    let remaining = 0;

    for (let r = 0; r < brickRow; r++) {
        for (let c = 0; c < brickCol; c++) {
            const b = bricks[r][c];
            if (b.hp <= 0) continue;

            remaining++;

            const closestX = clamp(ball.x, b.x, b.x + brickWidth);
            const closestY = clamp(ball.y, b.y, b.y + brickHeight);

            const dx = ball.x - closestX;
            const dy = ball.y - closestY;

            if (dx * dx + dy * dy < ball.r * ball.r) {
                if (Math.abs(dx) > Math.abs(dy)) ball.dx *= -1;
                else ball.dy *= -1;

                b.hp--;
                if (b.hp === 0) score++;
            }
        }
    }
    if (remaining === 0) nextLevel();
}

/* ---------- ä¸‹ä¸€é—œ ---------- */
function nextLevel() {
    level++;
    createBricks();
    resetBall();
}

/* ---------- ç¹ªåœ– ---------- */
function drawBall() {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = "#00ffcc";
    ctx.fill();
}
function drawPaddle() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(paddle.x, canvas.height - paddle.height - 10, paddle.width, paddle.height);
}
function drawBricks() {
    for (let r = 0; r < brickRow; r++) {
        for (let c = 0; c < brickCol; c++) {
            const b = bricks[r][c];
            if (b.hp > 0) {
                const x = brickPadding + c * (brickWidth + brickPadding);
                const y = brickOffsetTop + r * (brickHeight + brickPadding);
                b.x = x; b.y = y;
                ctx.fillStyle = b.hp === 2 ? "#cc6600" : "#ff9933";
                ctx.fillRect(x, y, brickWidth, brickHeight);
            }
        }
    }
}

/* ---------- ä¸»è¿´åœˆ ---------- */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBricks();
    drawBall();
    drawPaddle();

    collisionDetection();

    if (ball.x + ball.dx > canvas.width - ball.r || ball.x + ball.dx < ball.r) ball.dx *= -1;
    if (ball.y + ball.dy < ball.r) ball.dy *= -1;

    const paddleTop = canvas.height - paddle.height - 10;

    /* é«˜é€Ÿå¹³å°ç©¿è¶Šåˆ¤å®š */
    if (
        ball.dy > 0 &&
        ball.prevY + ball.r <= paddleTop &&
        ball.y + ball.r >= paddleTop &&
        ball.x >= paddle.x &&
        ball.x <= paddle.x + paddle.width
    ) {
        let hit = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
        hit = clamp(hit, -1, 1);

        let angle = Math.round(hit * maxBounceAngle / 5) * 5;
        let speed = getBallSpeed();
        let rad = angle * Math.PI / 180;

        ball.dx = speed * Math.sin(rad);
        ball.dy = -speed * Math.cos(rad);
        ball.y = paddleTop - ball.r;
    }

    if (ball.y > canvas.height) {
        lives--;
        if (lives === 0) {
            saveHighScore(score);
            canvas.style.display = "none";
            document.getElementById("menu").style.display = "block";
            return;
        }
        resetBall();
    }

    if (leftPressed) paddle.x -= paddle.speed;
    if (rightPressed) paddle.x += paddle.speed;
    paddle.x = clamp(paddle.x, 0, canvas.width - paddle.width);

    if (!ballLaunched) {
        ball.x = paddle.x + paddle.width / 2;
        ball.y = paddleTop - ball.r;
    } else {
        ball.prevX = ball.x;
        ball.prevY = ball.y;
        ball.x += ball.dx;
        ball.y += ball.dy;
    }

    document.getElementById("info").innerText =
        `é—œå¡ ${level} ï½œ åˆ†æ•¸ ${score} ï½œ å‰©é¤˜çƒæ•¸ ${lives}`;

    animationId = requestAnimationFrame(draw);
}
</script>
</body>
</html>
